{
  "name": "Redis-demo",
  "tagline": "Demo Redis",
  "body": "![1420999778redisrails.png](http://s5.postimg.org/f6fr893v7/1420999778redisrails.png) \r\n\r\nViệc tối ưu một trang web là một công việc khá quan trọng , nó làm cho việc trải nghiệm người dùng (UX) tốt hơn khi mà chương trình của chúng ta trở nên lớn hơn về số lượng người dùng hay dữ liệu. Khi tối ưu ở server mà ta đã tối ưu câu query hết mức, loại bỏ N+1... mà ta vẫn thấy chậm, lúc đó ta có thể nghĩ đến một phương án khác là sử dụng cache dữ liệu.\r\n\r\nTrong bài viết này mình sẽ giới thiệu Redis và demo một ứng dụng Rails sử dụng Redis để cache dữ liệu.\r\n\r\n# 1. Redis là gì?\r\nRedis là một dự án mã nguồn mở, dự án có hơn 20k stars và hơn 7k forks trên Github (một con số ấn tượng phải không). Redis thường được coi như là data structures server, điều đó có nghĩa là nó cung cấp quyền truy cập dữ liệu thông qua một tập các câu lệnh, các request sử dụng cấu trúc server-client với giao thức TCP sockets và một giao thức đơn giản khác. Vì vậy, các tiến trình khác nhau có thể query hay modify cùng một dữ liệu dưới nhiều cách khác nhau.\r\n\r\nRedis là một in-memory data structure store, điều này có nghĩa là Redis lưu dữ liệu ở trong bộ nhớ chính (RAM), lí giải tại sao Redis lại nhanh.\r\n\r\n## Tại sao lại chọn Redis?\r\nCó rất nhiều hệ thống lưu trữ dữ liệu ngoài kia như [Memcached](https://memcached.org/), [Voldemort](http://www.project-voldemort.com/voldemort/), [MongoDB](https://www.mongodb.com/), [Apache Casandra](http://cassandra.apache.org/)... Vậy tại sao lại chọn Redis?\r\n\r\nViệc sử dụng Redis có một số tính năng đặc biệt:\r\n- Redis sẽ đảm bảo việc lưu dữ liệu vào đĩa, thậm chí dữ liệu được thay đổi, sửa chữa thường xuyên. Ngoài ra Redis cũng rất nhanh nhưng vẫn ổn định.\r\n- Redis quan tâm đặc biệt vào hiệu quả bộ nhớ, vì vậy dữ liệu bên trong Redis sẽ sử dụng ít bộ nhớ hơn so với những hệ thống lưu trữ dữ liệu sử dụng ngôn ngữ lập trình bậc cao cùng loại.\r\n- Redis cung cấp mọt số các tính năng như sự sao chép (replication), tính bền bỉ (durability), phân cụm (cluster) hay độ khả dụng cao (high availability).\r\n\r\n## Kiểu dữ liệu\r\nRedis sử dụng dạng lưu trữ key-value, nhưng không hẳn là text thông thường, Redis hỗ trợ nhiều loại dữ liệu\r\n```TextileToHtml\r\n|_.Loại dữ liệu|_.Mô tả|\r\n|String|Redis sử dụng Binary-safe strings|\r\n|Set|Một tập các string duy nhất và không sắp xếp|\r\n|List|Tập các string được sắp xếp theo thứ tự được chèn vào, cơ bản giống như linked lists|\r\n|Sorted set|Giống Set nhưng các phần tử được sắp xếp thông qua một giá trị được gọi là score|\r\n|Hash|Các cặp key-value, nó giống như Hash ở trong Ruby hay Python|\r\n|Bit array|Lưu trữ dữ liệu ở dạng một mảng các bit|\r\n|HyperLogLog|Được sử dụng để ước lượng các yếu tố của một tập|\r\n```\r\n## Cài đặt\r\nLan man với lí thuyết thế là đủ, cùng download, giải nén và compile Redis với:\r\n```Terminal\r\n$ wget http://download.redis.io/releases/redis-3.2.5.tar.gz\r\n$ tar xzf redis-3.2.5.tar.gz\r\n$ cd redis-3.2.5\r\n$ make\r\n$ cp src/redis-server src/redis-cli /usr/bin\r\n```\r\nĐể khởi động Redis ta sử dụng câu lệnh:\r\n```Terminal\r\n$ redis-server\r\n```\r\n# 2. Tối ưu Rails app với Redis\r\n## Tạo dữ liệu\r\nỞ phần demo này mình có 2 bảng là User và Post\r\n```Ruby\r\n# app/models/post.rb\r\nclass Post < ActiveRecord::Base\r\n  belongs_to :user\r\nend\r\n\r\n# app/models/user.rb\r\nclass User < ActiveRecord::Base\r\n  has_many :posts\r\nend\r\n```\r\nViệc truy vấn với một lượng lớn dữ liệu sẽ mất khá nhiều thời gian query, sẽ mất nhiều thời gian hơn nữa khi ta response cho client.\r\nTiếp theo ta tạo dữ liệu từ  file `seed.rb`, ta cần cài đặt gem `faker` để tạo dữ liệu ảo.\r\n```Ruby\r\ngem \"faker\"\r\n```\r\nTa tạo ra 10 user và mỗi user có 10000 post\r\n```Ruby\r\n# db/seed.rb\r\n10.times do |n|\r\n  user = User.create! name: Faker::Name.name, address: Faker::Address.city\r\n  10000.times do |m|\r\n    Post.create! title: Faker::Lorem.sentence, content: Faker::Lorem.paragraph,\r\n      user: user\r\n  end\r\nend\r\n```\r\nỞ controller index ta load hết tất cả 100000 post và trả về ở dạng json.\r\n```Ruby\r\n# app/controllers/posts_controller.rb\r\nclass PostsController < ApplicationController\r\n  def index\r\n    @posts = Post.includes(:user).all\r\n    respond_to do |format|\r\n      format.json { render json: @posts, status: :ok }\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThử chạy chương trình xem có ổn không nào.\r\n\r\n![Selection_007.png](http://s5.postimg.org/3la6ea7rn/Selection_007.png) \r\n\r\n![Selection_008.png](http://s5.postimg.org/r0s3jmrir/Selection_008.png) \r\n\r\nTa có thể thấy là với 100000 bản ghi server mất 86ms để truy vấn dữ liệu và mất toàn bộ gần 21s để trả về được cho client dữ liệu dưới dạng json.\r\n\r\n## Khởi tạo Redis Rails\r\nTiếp theo ta cần cài đặt một số gem để có thể sử dụng Redis\r\n```Ruby\r\ngem \"redis\"\r\ngem \"redis-namespace\"\r\ngem \"redis-rails\"\r\ngem \"redis-rack-cache\"\r\n```\r\nTa cần khai báo với Rails rằng là sử dụng Redis như một `cache store`, ở đây ta cần khai báo địa chỉ host, cổng và số thứ tự database (Redis mặc định có 16 database được đánh số thứ tự từ 0-15)\r\n```Ruby\r\n# config/application.rb\r\nconfig.cache_store = :redis_store, {\r\n  host: \"localhost\",\r\n  port: 6379,\r\n  db: 0,\r\n}, {expires_in: 7.days}\r\n```\r\nTa cần phải tạo ra một Redis instance để có thể gọi được ở trong ứng dụng Rails, bằng việc sử dụng `redis-namespace` điều này khá dễ dàng. Sau này khi cần thực hiện query Redis sẽ thông qua biến này.\r\n```Ruby\r\n# config/initializers/redis.rb \r\n$redis = Redis::Namespace.new \"demo-redis\", :redis => Redis.new\r\n```\r\nGiờ thì ta đã có thể sử dụng được Redis để lưu trữ dữ liệu rồi\r\n```Ruby\r\n# app/controllers/posts_controller.rb\r\nclass PostsController < ApplicationController\r\n  def index\r\n    @posts = fetch_from_redis\r\n    respond_to do |format|\r\n      format.json { render json: @posts, status: :ok }\r\n    end\r\n  end\r\n\r\n  private\r\n    def fetch_from_redis\r\n      posts = $redis.get \"posts\"\r\n\r\n      if posts.nil?\r\n        posts = Post.includes(:user).all.to_json\r\n        $redis.set \"posts\", posts\r\n      end\r\n      JSON.load posts\r\n    end\r\nend\r\n```\r\nChạy thử và xem kết quả nào\r\n\r\n![Selection_005.png](http://s5.postimg.org/z2bqnskwj/Selection_005.png) \r\n------\r\n\r\n![Selection_006.png](http://s5.postimg.org/i37dm9z2r/Selection_006.png) \r\n\r\nServer không hề mất thời gian truy vấn dữ liệu thay vào đó là lấy dữ liệu từ Redis (rất nhanh) và cũng chỉ mất tổng cộng hơn 7s để trả lại dữ liệu cho client dưới dạng json, thời gian đã được giảm xuống còn 1/3 so với lúc trước.\r\n\r\n# Một số vấn đề gặp phải khi sử dụng redis\r\n### Khi Redis bị lỗi thì server của chúng ta cũng bị lỗi\r\nĐể khắc phục điều này ta cần tạo 1 exception cho việc gọi Redis (good practice), ta có thể viết lại hàm `fetch_from_redis`\r\n```Ruby\r\n# app/controllers/posts_controller.rb\r\ndef fetch_from_redis\r\n  begin\r\n    posts = $redis.get \"posts\"\r\n\r\n    if posts.nil?\r\n      posts = Post.includes(:user).all.to_json\r\n      $redis.set \"posts\", posts\r\n    end\r\n    posts = JSON.load posts\r\n  rescue => error\r\n    puts error.inspect\r\n    posts = Post.includes(:user).all\r\n  end\r\n  posts\r\nend\r\n```\r\n### Dữ liệu trả về không còn là Active Record\r\nMột điều cần lưu ý là khi ta load dữ liệu từ Redis thì ta cần phải chuyển dữ liệu cần lưu thành string thì mới có thể lưu vào được Redis, và khi lấy ra ta cần phải convert từ string thành hash. Vì vậy khi sử dụng dữ liệu ở view thì cần chú ý vì dữ liệu bây giờ không phải là Active Record nữa.\r\n\r\nViệc convert sang json và dump lại thành hash có thể mất nhiều thời gian, ta có thể  sử dụng [yajl-ruby](https://github.com/brianmario/yajl-ruby) hay [Oj](https://github.com/ohler55/oj)\r\n### Dữ liệu khi bị sửa đổi hay xóa thì dữ liệu trong redis sẽ không còn đúng nữa\r\nCó một vấn đề là khi ta cập nhật hay xóa dữ liệu thì khi ta lấy dữ liệu từ Redis ra sẽ không còn đúng nữa, vì vậy ta cần phải có một bước cập nhật dữ liệu Redis mỗi khi có thay đổi về dữ liệu.\r\n\r\nĐiều này giải quyết khá đơn giản là ta lại xóa dữ liệu trong Redis đi.\r\n```Ruby\r\nclass Post < ActiveRecord::Base\r\n  after_save :clear_cache\r\n\r\n  private\r\n  def clear_cache\r\n    $redis.del \"posts\"\r\n  end\r\nend\r\n\r\n```\r\n### Đặt key có tính phân biệt\r\nGiả định ở index ta chỉ lấy những posts của user hiện tại, khi đó ta sẽ gặp trường hợp là 2 user khác nhau sẽ lấy cùng một dữ liệu ở Redis vì vậy kết quả sẽ không đúng.\r\n\r\nĐể giải quyết vấn đề này cũng khá đơn giản, là ta chỉ cần đặt key khi lưu vào Redis có thể phân biệt được 2 user đó, ví dụ ta có thể đặt key là `posts&user_id=1` thay vì là `posts`\r\n\r\n# Tài liệu tham khảo\r\n- [https://www.sitepoint.com/rails-model-caching-redis/](https://www.sitepoint.com/rails-model-caching-redis/)\r\n- [Trang chủ Redis](http://redis.io/)\r\n- [Redis Rails](https://github.com/redis-store/redis-rails)\r\n- [https://github.com/antirez/redis](https://github.com/antirez/redis)",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}